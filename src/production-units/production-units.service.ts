import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';
import { CreateProductionUnitDto } from './dto/create-production-unit.dto';
import { UpdateProductionUnitDto } from './dto/update-production-unit.dto';
import { CreateSectorDto } from '../sectors/dto/create-sector.dto';

@Injectable()
export class ProductionUnitsService {
  constructor(private readonly prisma: PrismaService) {}

  async create(dto: CreateProductionUnitDto & { geometry?: Record<string, unknown>; surface?: number }, userId?: string) {
    const { geometry, surface, ...fieldData } = dto;
    
    const field = await this.prisma.field.create({
      data: fieldData,
      include: { plots: true },
    });

    if (field.plots.length === 0 && geometry && surface) {
      await this.prisma.plot.create({
        data: {
          name: field.name,
          fieldId: field.id,
          geometry: geometry as Prisma.InputJsonValue,
          surface: surface,
          color: field.color,
          isAutoGenerated: true,
        },
      });
    }

    if (userId) {
      return this.findOne(field.id, userId);
    }
    return this.prisma.field.findUnique({
      where: { id: field.id },
      include: { farm: true, plots: true },
    });
  }

  async findAll(userId: string) {
    return this.prisma.field.findMany({
      where: {
        farm: {
          users: {
            some: {
              userId,
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
      include: {
        farm: true,
        plots: true,
      },
    });
  }

  async findByFarm(farmId: string) {
    return this.prisma.field.findMany({
      where: { farmId },
      orderBy: { createdAt: 'desc' },
      include: { plots: true },
    });
  }

  async findOne(id: string, userId: string) {
    const field = await this.prisma.field.findFirst({
      where: {
        id,
        farm: {
          users: {
            some: {
              userId,
            },
          },
        },
      },
      include: {
        farm: true,
        plots: true,
      },
    });
    if (!field) {
      throw new NotFoundException(
        `Field with id "${id}" not found`,
      );
    }
    return field;
  }

  async update(id: string, dto: UpdateProductionUnitDto, userId: string) {
    await this.findOne(id, userId);
    return this.prisma.field.update({
      where: { id },
      data: dto,
    });
  }

  async remove(id: string, userId: string) {
    const field = await this.findOne(id, userId);
    
    const plots = await this.prisma.plot.findMany({
      where: { fieldId: id },
      include: {
        cropCycles: true,
      },
    });

    const hasCropCycles = plots.some(plot => plot.cropCycles.length > 0);
    if (hasCropCycles) {
      throw new ConflictException(
        'Cannot delete Field: it has CropCycles in one or more Plots',
      );
    }

    return this.prisma.field.delete({ where: { id } });
  }

  async subdivideField(
    fieldId: string,
    plotsData: CreateSectorDto[],
    userId: string,
  ) {
    const field = await this.findOne(fieldId, userId);

    const existingPlots = await this.prisma.plot.findMany({
      where: { fieldId },
    });

    const autoGeneratedPlots = existingPlots.filter(p => p.isAutoGenerated);
    
    if (autoGeneratedPlots.length > 0) {
      await this.prisma.plot.deleteMany({
        where: {
          id: { in: autoGeneratedPlots.map(p => p.id) },
        },
      });
    }

    const createdPlots = await Promise.all(
      plotsData.map(plotData =>
        this.prisma.plot.create({
          data: {
            name: plotData.name,
            sigpacCode: plotData.sigpacCode,
            geometry: plotData.geometry as Prisma.InputJsonValue | undefined,
            surface: plotData.surface,
            hasCadastralReference: plotData.hasCadastralReference,
            isCommunalPasture: plotData.isCommunalPasture,
            isPasturesCommonInCommon: plotData.isPasturesCommonInCommon,
            tenureRegime: plotData.tenureRegime,
            fieldId,
            color: plotData.color,
            facilityBuildingIds: plotData.facilityBuildingIds,
            isAutoGenerated: false,
          },
        }),
      ),
    );

    return this.findOne(fieldId, userId);
  }
}
