import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateExploitationDto } from './dto/create-exploitation.dto';
import { UpdateExploitationDto } from './dto/update-exploitation.dto';
import { Role } from '../auth/decorators/roles.decorator';
import { slugifyWithCollisionCheck } from '../common/utils/slugify';

@Injectable()
export class ExploitationsService {
  constructor(private readonly prisma: PrismaService) {}

  async create(dto: CreateExploitationDto, userId: string, role: Role = Role.OWNER) {
    const slug = await slugifyWithCollisionCheck(dto.name, async (s) => {
      const existing = await this.prisma.farm.findUnique({ where: { slug: s } });
      return !!existing;
    });
    const farm = await this.prisma.farm.create({ data: { ...dto, slug } });

    await this.prisma.userFarm.create({
      data: {
        userId,
        farmId: farm.id,
        role,
      },
    });

    return {
      ...farm,
      role,
    };
  }

  async createWithOnboarding(dto: CreateExploitationDto, userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        farms: {
          include: {
            farm: true,
          },
        },
      },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    const slug = await slugifyWithCollisionCheck(dto.name, async (s) => {
      const existing = await this.prisma.farm.findUnique({ where: { slug: s } });
      return !!existing;
    });
    const farm = await this.prisma.farm.create({
      data: { ...dto, slug },
    });

    await this.prisma.userFarm.create({
      data: {
        userId,
        farmId: farm.id,
        role: Role.OWNER,
      },
    });

    return {
      ...farm,
      role: Role.OWNER,
    };
  }

  async findAll(userId: string) {
    const farms = await this.prisma.farm.findMany({
      where: {
        users: {
          some: {
            userId,
          },
        },
      },
      include: {
        fields: true,
        users: {
          where: {
            userId,
          },
          select: {
            role: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    return farms.map((farm) => ({
      ...farm,
      role: farm.users[0]?.role || null,
    }));
  }

  async findOneBySlug(slug: string) {
    const farm = await this.prisma.farm.findUnique({
      where: { slug },
      include: {
        fields: {
          include: { plots: true },
        },
        waterConsumptions: {
          orderBy: { analysisDate: 'desc' },
        },
      },
    });
    if (!farm) {
      throw new NotFoundException(`Farm with slug "${slug}" not found`);
    }
    return farm;
  }

  async update(slug: string, dto: UpdateExploitationDto) {
    const farm = await this.findOneBySlug(slug);
    const data: UpdateExploitationDto & { slug?: string } = { ...dto };
    if (dto.name !== undefined && dto.name !== farm.name) {
      data.slug = await slugifyWithCollisionCheck(dto.name, async (s) => {
        const existing = await this.prisma.farm.findFirst({
          where: { slug: s, id: { not: farm.id } },
        });
        return !!existing;
      });
    }
    return this.prisma.farm.update({
      where: { id: farm.id },
      data,
    });
  }

  async remove(slug: string) {
    const farm = await this.findOneBySlug(slug);
    return this.prisma.farm.delete({ where: { id: farm.id } });
  }
}
