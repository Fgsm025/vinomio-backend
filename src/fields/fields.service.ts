import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';
import { ActivitiesService } from '../activities/activities.service';
import { CreateFieldDto } from './dto/create-fields.dto';
import { UpdateFieldDto } from './dto/update-fields.dto';
import { CreateLotDto } from '../lots/dto/lots.dto';

@Injectable()
export class FieldsService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly activitiesService: ActivitiesService,
  ) {}

  async create(
    dto: CreateFieldDto & {
      geometry?: Record<string, unknown>;
      surface?: number;
    },
    userId?: string,
  ) {
    const { geometry, surface, facilityBuildingIds, ...fieldData } = dto;

    const field = await this.prisma.field.create({
      data: fieldData,
      include: { plots: true },
    });

    if (facilityBuildingIds?.length) {
      await this.prisma.facility.updateMany({
        where: { id: { in: facilityBuildingIds } },
        data: { fieldId: field.id },
      });
    }
    
    if (field.farmId) {
      this.activitiesService.log({
        type: 'FIELD_CREATED',
        title: 'Field created',
        description: `New field "${field.name}" registered`,
        icon: 'material-symbols:landscape-outline-rounded',
        entityId: field.id,
        entityType: 'field',
        farmId: field.farmId,
        metadata: {
          productionType: field.productionType,
          surface: field.surface,
        },
      });
    }

    if (userId) {
      return this.findOne(field.id, userId);
    }
    return this.prisma.field.findUnique({
      where: { id: field.id },
      include: { farm: true, plots: true, facilities: true },
    });
  }

  async findAll(userId: string) {
    return this.prisma.field.findMany({
      where: {
        farm: {
          users: {
            some: {
              userId,
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
      include: {
        farm: true,
        plots: true,
        facilities: true,
      },
    });
  }

  async findByFarm(farmId: string) {
    return this.prisma.field.findMany({
      where: { farmId },
      orderBy: { createdAt: 'desc' },
      include: { plots: true, facilities: true },
    });
  }

  async findOne(id: string, userId: string) {
    const field = await this.prisma.field.findFirst({
      where: {
        id,
        farm: {
          users: {
            some: {
              userId,
            },
          },
        },
      },
      include: {
        farm: true,
        plots: true,
        facilities: true,
      },
    });
    if (!field) {
      throw new NotFoundException(`Field with id "${id}" not found`);
    }
    return field;
  }

  async update(id: string, dto: UpdateFieldDto, userId: string) {
    await this.findOne(id, userId);
    const { farmId, facilityBuildingIds, ...rest } = dto;
    const data: Prisma.FieldUpdateInput = {
      ...rest,
      ...(farmId !== undefined && {
        farm: farmId
          ? { connect: { id: farmId } }
          : { disconnect: true },
      }),
    } as Prisma.FieldUpdateInput;
    const updated = await this.prisma.field.update({
      where: { id },
      data,
    });
    if (facilityBuildingIds !== undefined) {
      await this.prisma.facility.updateMany({
        where: { fieldId: id },
        data: { fieldId: null },
      });
      if (facilityBuildingIds.length > 0) {
        await this.prisma.facility.updateMany({
          where: { id: { in: facilityBuildingIds } },
          data: { fieldId: id },
        });
      }
    }
    return this.findOne(id, userId);
  }

  async remove(id: string, userId: string) {
    await this.findOne(id, userId);
    await this.prisma.plot.deleteMany({ where: { fieldId: id } });
    return this.prisma.field.delete({ where: { id } });
  }

  async subdivideField(
    fieldId: string,
    plotsData: CreateLotDto[],
    userId: string,
    replaceAll = false,
  ) {
    const field = await this.findOne(fieldId, userId);

    if (replaceAll) {
      await this.prisma.plot.deleteMany({ where: { fieldId } });
    } else {
      const existingPlots = await this.prisma.plot.findMany({
        where: { fieldId },
      });
      const autoGeneratedPlots = existingPlots.filter((p) => p.isAutoGenerated);
      if (autoGeneratedPlots.length > 0) {
        await this.prisma.plot.deleteMany({
          where: {
            id: { in: autoGeneratedPlots.map((p) => p.id) },
          },
        });
      }
    }

    const createdPlots = await Promise.all(
      plotsData.map((plotData) =>
        this.prisma.plot.create({
          data: {
            name: plotData.name,
            sigpacCode: plotData.sigpacCode,
            geometry: plotData.geometry as Prisma.InputJsonValue | undefined,
            surface: plotData.surface,
            hasCadastralReference: plotData.hasCadastralReference,
            isCommunalPasture: plotData.isCommunalPasture,
            isPasturesCommonInCommon: plotData.isPasturesCommonInCommon,
            tenureRegime: plotData.tenureRegime,
            fieldId,
            isAutoGenerated: false,
          },
        }),
      ),
    );

    return this.findOne(fieldId, userId);
  }
}
